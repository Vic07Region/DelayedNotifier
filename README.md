# DelayedNotifier - Система отложенных уведомлений

Тестовый микросервис отложенных уведомлений в рамках обучения в техношколе W B (пишу так что бы в поиске хуже искалось)

## Что это вообще такое?

DelayedNotifier - это микросервис, который:
- Принимает запрос на отправку уведомления
- Планирует его отправку на нужное время
- Отправляет уведомление точно когда нужно
- Обрабатывает ошибки и делает повторные попытки


## Быстрый старт (5 минут)

Если хочешь просто посмотреть, как это работает:

```bash
# 1. Убедись, что у тебя установлен Docker
docker --version

# 2. Запускаем только базы данных (быстро для разработки)
docker-compose -f docker-compose.dev.yml up -d

# 3. Ждем 30 секунд, чтобы все поднялось
sleep 30

# 4. Делаем миграции базы данных
docker-compose run --rm migrations

# 5. Запускаем само приложение
docker-compose up --build -d

# 6. Проверяем, что все работает
curl http://localhost:8080/
```

Если все ок, увидишь веб-интерфейс на http://localhost:8080/

## Тест-драйв (попробуй прямо сейчас)

После запуска можешь создать тестовое уведомление:

```bash
curl -X POST http://localhost:8080/notify/ \
  -H "Content-Type: application/json" \
  -d '{
    "recipient": "test@example.com",
    "channel": "email", 
    "payload": "{\"subject\":\"Привет!\",\"body\":\"Как дела?\"}",
    "scheduled_at": "2024-12-25T10:00:00Z"
  }'
```

Отправленные письма можно посмотреть в MailHog: http://localhost:8025

## Структура проекта (что где лежит)

Проект разбит на логические части:

```
DelayedNotifier/
├── cmd/                    # Точка входа в приложение
├── internal/              # Вся логика приложения
│   ├── app/               # Главный файл приложения
│   ├── config/            # Работа с настройками
│   ├── delivery/          # HTTP обработчики (API)
│   ├── domain/            # Основные модели данных
│   ├── repository/        # Работа с базой данных
│   ├── service/           # Бизнес-логика
│   └── worker/            # Фоновые задачи
├── migrations/            # SQL скрипты для БД
├── web/                   # Простая веб-страница
├── tests/                 # Тесты (покрытие ~80%)
├── Dockerfile             # Как собрать образ
└── docker-compose.yml     # Конфигурация всех сервисов
```

### Основные компоненты:

**HTTP API** (`internal/delivery/`) - принимает запросы от клиентов
**Сервисный слой** (`internal/service/`) - вся бизнес-логика здесь
**Репозитории** (`internal/repository/`) - работа с PostgreSQL и Redis
**Воркеры** (`internal/worker/`) - обрабатывают очередь сообщений

## Технологии (что использовал)

- **Go 1.25** - основной язык
- **PostgreSQL 15** - основная база данных
- **Redis 7** - кэш для быстрого доступа к данным
- **RabbitMQ 3.12** - очередь сообщений
- **Gin** - веб-фреймворк для Go
- **Docker** - контейнеризация всего

PostgreSQL для надежного хранения, 
Redis для скорости (не нужно каждый раз лезть в БД), 
RabbitMQ для асинхронной обработки - чтобы пользователь не ждал, пока уведомление отправится.

## Как работает система 

1. **Пользователь** отправляет POST запрос с данными уведомления
2. **API** валидирует данные и сохраняет в PostgreSQL
3. **Сервис** кладет задачу в очередь RabbitMQ
4. **Consumer** забирает задачу из очереди и отправляет уведомление
5. **Результат** сохраняется обратно в БД

Воспользовался советом из группы 
и реализовал очередь вот таким образом
- ✔ Per-message queue (на один таск — одна очередь)
- ✔ Queue TTL — очередь живёт короткое время
- ✔ Message TTL — сообщение живёт внутри очереди ограниченное время
- ✔ Dead Letter Exchange (DLX) → основная очередь

из этой очереди и берет консьюмер задачи для отправки
## API

### Создание уведомления
```http
POST /notify/
Content-Type: application/json

{
  "recipient": "user@example.com",
  "channel": "email",
  "payload": "{\"subject\":\"Привет!\",\"body\":\"Как дела?\"}",
  "scheduled_at": "2024-12-25T10:00:00Z"
}
```

### Получение уведомления
```http
GET /notify/{id}
```

### Отмена уведомления
```http
DELETE /notify/{id}
```

### Веб-интерфейс
Просто зайди на http://localhost:8080/ - там простая форма для создания уведомлений.

## Тестирование (проверял что работает)

В проекте есть тесты для всех основных компонентов:

```bash
# Запуск всех тестов
go test ./...

# С покрытием кода
go test -cover ./...

# Конкретный тест
go test -v ./internal/service/...
```

### Локальная разработка без Docker
```bash
# Запускаем только БД
docker-compose -f docker-compose.dev.yml up -d

# Компилируем и запускаем
go run ./cmd/main.go runserver

# Для изменений в БД
go run ./cmd/main.go migrate up
```

### Отладка
```bash
# Заходим в контейнер
docker-compose exec delayed-notifier sh

# Смотрим что там есть
ls -la /web/

# Проверяем переменные окружения
env | grep DELAYED_NOTIFIER
```

## Полезные ссылки

- **Веб-интерфейс**: http://localhost:8080/
- **RabbitMQ Management**: http://localhost:15672 (guest/guest)
- **MailHog**: http://localhost:8025
- **База данных**: localhost:5432 (postgres/postgres)
- **Redis**: localhost:6379


*Проект сделан для техношколы. и брать его как эталон не стоит!*
